---
layout: post
title:  "Year Of Coding In Review: Catastrophic Success"
date:   2025-09-29 00:10:04 +0200
categories: update 
---
Roughly a year ago I had the very bad idea of learning to code, which made me incredibly angry. The constant rage kept me going though, and eventually became a perpetuum mobile that was refueled every evening when the compiler bullied me.  
What helped me a lot was the fleeting sense of achievement when I fiddled with code and exchanged it for a green tile on GitHub. After a while, however, I noticed that I was making mini-changes, sometimes to the game design document or this blog, just to keep the streak going. This avoidance was made worse by having bigger problems to solve, such as the multiplayer networking feature for my game. Although it can be divided into multiple little parts, it wasn’t something a noob could casually tackle in a café.  

So recently, I changed up my strategy. My goal is to fiddle with code each day (be it a minute or an hour) to create a repetitive ritual. Starting from scratch with variables, arrays, loops. Really, stuff that I should know inside and out already after a year.  

![A random picture of a utility box](https://live.staticflickr.com/65535/54753278608_c515d470e3_b.jpg)

In practice, I noticed programming often has problems that are chained to other problems if you fully want to wrap your mind around how it works exactly. Constructor methods, for example, can be summed up in one sentence: a method that receives a value. But how do I return multiple ones? Can I put dictionaries into it? What does *static* mean exactly again? In total, this rudimentary understanding was the biggest cause of frustration for me. Perhaps I already understand how to instantiate an object, but when I tried to do it in a class (spoiler: doesn’t work) I was back at debugging again, although I had set out to solve something completely different.  

The good thing about all of this is that when I started to revisit all these little details, the main concept (i.e. the constructor) was already understood in its function. So I could use the brain juice that was left at the end of a workday to tinker around and peek a bit under the hood, which sometimes accidentally leads to me experiencing something that can potentially be described as joy.  

Looking back, learning programming for a year was super frustrating, and it still feels as if I barely made progress. But although nothing can convince me that it didn’t start catastrophically, I’m more open to the idea that it won’t end the same way. In essence, the biggest success of the last year was simply getting started. Also, realizing that you don’t have to be good at something in order to do it (except [skateboarding](https://lemonspurple.github.io/update/projects/2025/08/07/concussion-leading-to-multiplayer-framework-evaluation.html), perhaps) and that learning itself can be a legitimate hobby.
